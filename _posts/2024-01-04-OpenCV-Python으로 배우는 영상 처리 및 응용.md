# OpenCV-Python으로 배우는 영상 처리 및 응용

- 7장 영역 처리
    
    ### 회선(convolution)
    
    마스크의 크기가 3*3이고 입력 이미지와 출력 이미지의 크기가 같다고 하자. 이 때 한 픽셀에서 컨볼루션 연산을 수행하면 그 픽셀의 주변 8픽셀까지 출력 픽셀에 관여하게 된다. 이 때 마스크의 값을 잘 조절하면 블러링, 샤프닝 등과 같이 원하는 특징을 부각시켜 출력 이미지를 만들 수 있게 된다.
    
    ### 블러링
    
    마스크 각각의 값은 1보다 작으면서 같고, 모든 합이 1이면 블러링 처리가 된다. 
    
    | 1/9 | 1/9 | 1/9 |
    | --- | --- | --- |
    | 1/9 | 1/9 | 1/9 |
    | 1/9 | 1/9 | 1/9 |
    
    마스크가 위와 같고 한 픽셀에서 컨볼루션 연산을 수행한다고 하자. 다음 출력 픽셀을 계산할 때 이전 픽셀과 주변 8픽셀을 포함한 9개의 픽셀이 모두 1/9만큼 다음 출력 픽셀에 반영된다. 즉 주변 픽셀끼리 비슷한 값을 가지게 되어 흐려지는 효과가 나타나는 것이다. 이 때 마스크의 합은 1이기 때문에 밝기는 크대로 유지된다.
    
    ### 밝기가 그대로 유지 된다는 것
    
    컨볼루션 연산을 수행할 때, 마스크의 합이 1이면 이미지의 밝기는 그대로 유지된다. 픽셀은 0~255 값을 가지는데, 마스크의 값이 1보다 작으면 입력과 출력 사이 픽셀 값의 스케일이 작아지게 되므로 밝기가 낮아지게 되는 것이다.
    
    ### 샤프닝
    
    블러링은 주변 픽셀의 값을 비슷하게 만들었지만 샤프닝에서는 마스크 원소들의 값 차이가 커지도록 구성함으로써 해당 픽셀과 주변 픽셀의 차이를 크게 만든. 마스크의 중심을 중심계수, 주변을 주변계수라고 한다. 중심계수를 주계수보다 큰 값을 가지게하고 블러링과 같이 마스크의 합이 1이되게 하면 밝기가 유지되는 샤프닝 마스크를 만들 수 있다.
    
    | 0 | -1 | 0 |
    | --- | --- | --- |
    | -1 | 5 | -1 |
    | 0 | -1 | 0 |
    
    ### 에지
    
    영상처리에서 에지는 화소값이 급격하게 변화하는 부분으로 정의할 수 있다. 화소값이 높→낮이나 낮→높아지는 부분을 에지라고 한다. 이미지에서 에지를 검출하는 방법에는 이웃하는 화소의 차분이 특정 임계값보다 높으면 에지로 지정하거나 1차 미분 마스크나 2차 미분 마스크를 이용하는 것이 있다.
    
    ### 1차 미분 마스크
    
    미분은 함수의 순간 변화율을 계산하는 과정을 의미한다. 에지는 화소가 급격히 변화하는 부분이기 때문에 함수의 변화율을 취하는 미분 연산을 통해 에지를 검출할 수 있다. 화소에서 밝기의 기울기를 계산하고 이 기울기의 크기를 구하면 에지가 된다. 하지만 이미지, 영상은 연속된 값이 아닌 이산된 데이터가 나열되어 있기 때문에 미분이 불가능하고, 따라서 해당 화소에서의 기울기는 구하지 못하지만 주변 화소와의 기울기로 근사할 수 있다.
    
    $$
    G[f(x,y)] = \begin{bmatrix} G_x \\ G_y \end{bmatrix} = \begin{bmatrix} \frac{\partial f(x,y)}{\partial x} \\ \frac{\partial f(x,y)}{\partial y} \end{bmatrix} \\
    G_x = \lim_{dx \to 1}\frac{f(x+dx) - f(x,y)}{dx} \doteqdot f(x+1, y) - f(x,y), dx=1 \\
    G_y = \lim_{dy \to 1}\frac{f(x,y+dy) - f(x,y)}{dy} \doteqdot f(x, y+1) - f(x,y), dy=1 \\
    G[f(x,y)] \doteqdot \sqrt{G_x^2 + G_y^2} \approx |G_x| + |G_y| \\
    \theta = tan^{-1} (\frac{G_y}{G_x})
    $$
    
    위 수식에서 2, 3번 라인은 각각 (x,y)와 (x+1, y), (x, y+1) 사이의 기울기를 의미한다. 4번 라인은 x, y에서의 기울기의 크기를 L2 norm을 이용해서 구하는 것이고, L2 norm을 L1 norm으로 근사화시켜 표현한 것이다. 마지막으로 $\theta$ 는 $tan(\theta) = \frac{G_y}{G_x}$ 에서 역함수를 통해 구한 것이다. $f(x,y)$ 를 이용해서 마스크를 표현하면 다음과 같이 나타낼 수 있다.
    
    | f(x-1,y-1) | f(x,y-1) | f(x+1,y-1) |
    | --- | --- | --- |
    | f(x-1,y) | f(x,y) | f(x+1,y) |
    | f(x-1,y+1) | f(x,y+1) | f(x+1,y+1) |
    
    1차 미분 마스크
    
    | 0 | 0 | 0 |
    | --- | --- | --- |
    | 0 | -1 | 0 |
    | 0 | 1 | 0 |
    
    y방향 마스크
    
    | 0 | 0 | 0 |
    | --- | --- | --- |
    | 0 | -1 | 1 |
    | 0 | 0 | 0 |
    
    x 방향 마스크
    
    즉 f(x,y)와 f(x+1,y), f(x,y+1) 사이의 변화량은 f(x,y)의 화소를 기준으로 바로 아래에 있는 화소와 오른쪽에 있는 화소와의 기울기를 의미한다. 1차 미분 마스크에 y 방향 마스크와 x 방향 마스크를 적용하면 출력값이 $f(x,y+1) - f(x,y), f(x+1,y)-f(x,y)$ 가 되어 $G_x, G_y$ 가 구해지게 된다. 최종적으로 수식의 라인 4번을 통해 $G_x, G_y$ 의 크기를 구하면 출력 이미지가 완성된다.
    
    ### 로버츠 마스크(Roberts)
    
    | 1 | 0 | 0 |
    | --- | --- | --- |
    | 0 | -1 | 0 |
    | 0 | 0 | 0 |
    
    대각방향 마스크1
    
    | 1 | 0 | 0 |
    | --- | --- | --- |
    | 0 | -1 | 0 |
    | 0 | 0 | 0 |
    
    대각방향 마스크2
    
    ![Untitled](OpenCV-Python%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%87%E1%85%A2%E1%84%8B%E1%85%AE%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%89%E1%85%A1%E1%86%BC%20%E1%84%8E%E1%85%A5%E1%84%85%E1%85%B5%20%E1%84%86%E1%85%B5%E1%86%BE%20%E1%84%8B%E1%85%B3%E1%86%BC%E1%84%8B%E1%85%AD%E1%86%BC%209715f4cc5e8a4d7f93eb4b77751d608b/Untitled.png)
    
    위는 로버츠 마스크를 이미지에 적용한 예시이다. dst1과 dst2는 각각 대각방향 마스크1, 2를 적용한 것이고 roberts egde는 dst1과 dst2의 크기를 합한 것이다. 대각방향 마스크1은 11시 방향으로 마스크가 구성되어 있는데, dst1은 왼쪽 위 대각선에 해당하는 에지가 검출되어 있다. 이는 대각방향 마스크1이 왼쪽 위에서 오른쪽 아래로 값이 크게 변화하는 부분을 검출하기 때문에 dst1과 같은 결과가 나타나는 것이다. 로버츠 마스크는 계산이 단순하지만 한 번만 차분을 계산하기 때문에 차분의 크기가 작고, 이로 인해서 경계가 확실한 에지만을 추출하며, 잡음에 매우 민감하다.
    
    ### 차분을 한 번만 계산한다는 것
    
    로버츠 마스크로 연산을 1회 수행했을 때 $f(x-1,y-1) - f(x,y)$ 와 같이 하나의 픽셀 관계에 대해서만 연산되므로 차분이 한 번만 계산된다고 할 수 있다.
    
    | -1 | 0 | 1 |
    | --- | --- | --- |
    | -1 | 0 | 1 |
    | -1 | 0 | 1 |
    
    하지만 마스크가 위와 같이 구성되어있다면 
    
    $$
    f(x+1,y-1) - f(x-1,y-1) + f(x+1, y) - f(x-1,y) + f(x+1,y+1) - f(x-1,y+1)
    $$
    
    과 같이 차분이 총 3번 계산된 것을 확인할 수 있다.
    
    ### 프리윗(Prewitt) 마스크
    
    프리윗 마스크는 로버츠 마스크의 단점을 보완하기 위해 고안되었다. 차분을 1회 계산하는 로버츠 마스크와 달리 프리윗 마스크는 차분이 3번 계산되기 때문에 에지의 강도가 강하며, 수직과 수평 에지를 동등하게 찾는 데 효과적이다.
    
    | -1 | 0 | 1 |
    | --- | --- | --- |
    | -1 | 0 | 1 |
    | -1 | 0 | 1 |
    
    수직 마스크
    
    | -1 | -1 | 1 |
    | --- | --- | --- |
    | 0 | 0 | 0 |
    | 1 | 1 | 1 |
    
    수평 마스크
    
    ![Untitled](OpenCV-Python%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%87%E1%85%A2%E1%84%8B%E1%85%AE%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%89%E1%85%A1%E1%86%BC%20%E1%84%8E%E1%85%A5%E1%84%85%E1%85%B5%20%E1%84%86%E1%85%B5%E1%86%BE%20%E1%84%8B%E1%85%B3%E1%86%BC%E1%84%8B%E1%85%AD%E1%86%BC%209715f4cc5e8a4d7f93eb4b77751d608b/Untitled%201.png)
    
    dst1과 dst2에서 수직, 수평 에지가 잘 검출된 것을 확인할 수 있고 두 결과를 합친 최종 출력 prewitt edge 또한 수직과 수평 에지 모두 잘 검출된 것을 확인할 수 있다.
    
    ### 소벨(Sobel) 마스크
    
    소벨 마스크는 에지 추출을 위한 가장 대표적인 1차 미분 연산자이다.
    
    | -1 | 0 | 1 |
    | --- | --- | --- |
    | -2 | 0 | 2 |
    | -1 | 0 | 1 |
    
    수직 마스크
    
    | -1 | -2 | -1 |
    | --- | --- | --- |
    | 0 | 0 | 0 |
    | 1 | 2 | 1 |
    
    수평 마스크
    
    프리윗 마스크와 유사하지만 중심 계수에 대한 차분을 2배로 계산한다. 중심 계수에 대한 차분 비중을 높였기 때문에 대각선 방향의 에지도 잘 검출한다.
    
    ![Untitled](OpenCV-Python%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%87%E1%85%A2%E1%84%8B%E1%85%AE%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%89%E1%85%A1%E1%86%BC%20%E1%84%8E%E1%85%A5%E1%84%85%E1%85%B5%20%E1%84%86%E1%85%B5%E1%86%BE%20%E1%84%8B%E1%85%B3%E1%86%BC%E1%84%8B%E1%85%AD%E1%86%BC%209715f4cc5e8a4d7f93eb4b77751d608b/Untitled%202.png)
    
    중심 계수에 대한 차분 비중을 높였는데 대각선 방향의 에지도 잘 검출하는 이유는 마스크의 -2 값에 대해 위, 아래 대각선 방향의 값은 1이므로
    
    $f(x+1,y-1) - 2f(x-1, y), f(x+1,y+1) - 2(f(x-1,y)$, 가 된다. 따라서 대각 방향에 해당하는 차분의 크기가 커지기 때문이라고 할 수 있다.
    
    | -1 | 0 | 1 |
    | --- | --- | --- |
    | -2 | 0 | 2 |
    | -1 | 0 | 1 |
    
    ### 2차 미분 마스크(라플라시안 에지 검출)
    
    1차 미분 연산자는 밝기가 점진적으로 변화하는 부분까지도 검출하여 많은 에지가 나타날 수 있다. 이를 보완하는 방법으로 한 번 더 미분을 수행하는 2차 미분 연산자가 있다. 1차 미분은 화소 사이의 변화량이고 2차 미분은 변화량의 크기이다. 즉 변화량 자체를 검출하는 1차 미분 마스크보다 변화량의 크기를 검출하는 2차 미분 마스크가 더 둔감하다. 다시 말해 1차 미분 마스크에는 밝기가 급격하게 바뀌는 부분과 밝기가 점진적으로 증가하거나 감소하는 부분이 포함되어 있는 반면 2차 미분 마스크는 점진적으로 변화하는 부분은 검출하지 않는다. 밝기가 급격하게 바뀌는, 변화량의 크기가 큰 부분만 검출한다.
    
    $$
    f''(x) = \lim_{h \to 0} \frac {f(x+h) - 2f(x) + f(x-h)}{h^2}
    $$
    
    위 수식은 이계도함를 단일 극한으로 썼을 때를 나타내고, 이계대칭도함수라고 불린다. 위 수식을 이용해 1차 미분 마스크를 한번 더 미분하면
    
    $$
    \frac{\partial^2 f}{\partial x^2} = \frac{\partial f(x+1,y)}{\partial x} - \frac{\partial f(x,y)}{\partial x} \\
    = [f(x+1,y)-f(x,y)] - [f(x,y) - f(x-1,y)] = f(x+1,y) -2f(x,y) -f(x-1,y) \\
    \\
    
    \frac{\partial^2 f}{\partial y^2} = \frac{\partial f(x,y+1)}{\partial y} - \frac{\partial f(x,y)}{\partial y} \\
    = [f(x,y+1)-f(x,y)] - [f(x,y) - f(x,y-1)] = f(x,y+1) -2f(x,y) -f(x,y-1) \\
    $$
    
    최종적으로 다음과 같은 라플라시안 마스크 공식이 완성된다.
    
    $$
    
    \triangledown^2f(x,y) = f(x-1,y)+f(x+1,y)+f(x,y-1)+f(x,y+1)-4f(x,y)
    $$
    
    이 라플라시안 마스크 공식을 3*3 마스크에 적용하면 중심 계수를 4배로 하고 상하좌우 화소의 계수를 1로 하면서 반대 부호를 갖게 한다.
    
    | 0 | -1 | 0 |
    | --- | --- | --- |
    | -1 | 4 | -1 |
    | 0 | -1 | 0 |
    
    | 0 | 1 | 0 |
    | --- | --- | --- |
    | 1 | -4 | 1 |
    | 0 | 1 | 0 |
    
    4방향 마스크
    
    | -1 | -1 | -1 |
    | --- | --- | --- |
    | -1 | 8 | -1 |
    | -1 | -1 | -1 |
    
    | 1 | 1 | 1 |
    | --- | --- | --- |
    | 1 | -8 | 1 |
    | 1 | 1 | 1 |
    
    8방향 마스크
    
    ![Untitled](OpenCV-Python%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%87%E1%85%A2%E1%84%8B%E1%85%AE%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%89%E1%85%A1%E1%86%BC%20%E1%84%8E%E1%85%A5%E1%84%85%E1%85%B5%20%E1%84%86%E1%85%B5%E1%86%BE%20%E1%84%8B%E1%85%B3%E1%86%BC%E1%84%8B%E1%85%AD%E1%86%BC%209715f4cc5e8a4d7f93eb4b77751d608b/Untitled%203.png)
    
    8방향 마스크를 적용했을 때 4방향 마스크보다 에지 검출이 잘 수행되는 것을 확인할 수 있다.
    
    ### LoG와 DoG(Laplacian of Gaussian, Difference of Gaussian)
    
    라플라시안은 잡음에 민감한 단점이 있기때문에, 잡음을 먼저 제거하고 라플라시안을 적용하여 강건한 에지 검출 마스크를 만들 수 있다. 잡음 제거 방법으로는 미디언, 최대, 최소값 필터링 등이 있지만 모두 비선형 공간 필터링이기 때문에 선형 공간 필터링인 가우시안 스무딩 마스크를 선택한다.  가우시안 스무딩 마스크와 라플라시안 모두 선형 필터링이기 때문에 하나로 합쳐서 단일 마스크로 계산할 수 있다. 즉 2차원 가우시안 함수를 두 번 미분한 것과 같다.
    
    $$
    G(x,y)=\frac{1}{2\pi\sigma^2}e^-\frac{x^2+y^2}{2\sigma^2}\\
    \frac{\partial^2 G(x,y)}{\partial x^2}=\frac{1}{\pi\sigma^4}[-\frac{1}{2} -\frac{x^2}{\sigma^4}]e^-\frac{x^2+y^2}{2\sigma^2} \\
    
    \frac{\partial^2 G(x,y)}{\partial y^2}=\frac{1}{\pi\sigma^4}[-\frac{1}{2} -\frac{y^2}{\sigma^4}]e^-\frac{x^2+y^2}{2\sigma^2} \\
    LoG(x,y)=\frac{1}{\pi\sigma^4}[1-\frac{x^2+y^2}{2\sigma^2}]e^-\frac{x^2+y^2}{2\sigma^2}
    $$
    
    LoG는 복잡한 공식에 의해 마스크를 생성해야 하기에 수행시간이 오래 걸린다. 이런 단점을 보완하면서 LoG와 유사한 기능을 하는 단순한 방법이 DoG이다. DoG는 단순히 가우시안의 차를 이용해서 마스크를 구성한다.
    
    $$
    DoG(x,y)=G_1(x,y)-G_2(x,y) \\
    (\frac{1}{2\pi\sigma_1^2}e^-\frac{x^2+y^2}{2\sigma_1^2}) - (\frac{1}{2\pi\sigma_2^2}e^-\frac{x^2+y^2}{2\sigma_2^2})
    $$
    
    ![Untitled](OpenCV-Python%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%87%E1%85%A2%E1%84%8B%E1%85%AE%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%89%E1%85%A1%E1%86%BC%20%E1%84%8E%E1%85%A5%E1%84%85%E1%85%B5%20%E1%84%86%E1%85%B5%E1%86%BE%20%E1%84%8B%E1%85%B3%E1%86%BC%E1%84%8B%E1%85%AD%E1%86%BC%209715f4cc5e8a4d7f93eb4b77751d608b/Untitled%204.png)
    
    ### 케니 에지 검출
    
    대부분의 에지 검출 방법은 잡음을 에지로 인식하는 문제에 노출돼있다. 영상에서 잡음은 다른 부분과 경계를 이루는 경우가 많기 때문이다. 케니 에지 검출은 비최대치 억제와 이력 임계 처리 방법을 통해 검출될 에지를 선별한다. 케니 에지 검출은 다음과 같은 순서의 알고리즘으로 구성되어있다.
    
    1. 블러링을 통한 노이즈 제거 (가우시안 블러링)
    2. 화소 기울기의 강도와 방향 검출 (소벨 마스크)
    3. 비최대치 억제(non-maximum suppression)
    4. 이력 임계값으로 에지 결정
    
    5*5 크기의 마스크를 가진 가우시안 블러링으로 불필요한 잡음을 어느정도 제거한 후 소벨 마스크로 회선을 적용한다. 이 단계에서의 출력인 $(G_x, G_y)$ 를 이용해서 화소 기울기의 크기와 방향을 계산한다. 방향은 0, 45, 90, 135로 근사한다. 이 때 에지와 기울기의 방향은 수직을 이룬다. 에지를 기준으로 양 옆 기울기 변화가 크기 때문이다.
    
    | 0 | 1 | 2 |
    | --- | --- | --- |
    | 3 | 4 | 5 |
    | 6 | 7 | 8 |
    
    4개의 방향으로 근사한다는 것은 $(G_x, G_y)$ 가 위와 같은 변화량을 가진다고 할 때, 방향에 따라 각각 (3,5), (0,8), (1,7), (2,6) 값을 가진 픽셀이 선택되는 것을 의미한다. 이 선택된 2개의 픽셀과 현재 화소의 에지 강도를 비교하여 최대치가 아니면 억제되고, 최대치인 것만 에지로 결정한다. 또한 임계값을 High, Low 두 개로 설정해서 High가 넘고 Low보다 밑으로 내려가지 않는 에지만을 에지로 선택한다.
    
    ![Untitled](OpenCV-Python%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%87%E1%85%A2%E1%84%8B%E1%85%AE%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%89%E1%85%A1%E1%86%BC%20%E1%84%8E%E1%85%A5%E1%84%85%E1%85%B5%20%E1%84%86%E1%85%B5%E1%86%BE%20%E1%84%8B%E1%85%B3%E1%86%BC%E1%84%8B%E1%85%AD%E1%86%BC%209715f4cc5e8a4d7f93eb4b77751d608b/Untitled%205.png)
    
    ### 최대값/최소값 필터링
    
    마스크의 크기가 3*3일 때, 이 영역안에 있는 화소중 가장 크거나 가장 작은 값을 출력값으로 정하는 필터링이다. 최대값 필터링은 최대값만 선택되기 때문에 출력 이미지의 밝기가 증가하고 최소값 필터링은 어두워진다.
    
    ![Untitled](OpenCV-Python%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%87%E1%85%A2%E1%84%8B%E1%85%AE%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%89%E1%85%A1%E1%86%BC%20%E1%84%8E%E1%85%A5%E1%84%85%E1%85%B5%20%E1%84%86%E1%85%B5%E1%86%BE%20%E1%84%8B%E1%85%B3%E1%86%BC%E1%84%8B%E1%85%AD%E1%86%BC%209715f4cc5e8a4d7f93eb4b77751d608b/Untitled%206.png)
    
    ### 평균값 필터링
    
    마스크의 영역에 해당하는 화소값들의 평균을 출력으로 내보내는 방법이다. 화소값들의 평균이기 때문에 블러링의 효과가 나타난다. 블러링 마스크를 적용한 결과와 같다. 3*3의 마스크일 때 각각의 마스크값이 1/9인 것과 화소값들을 모두 더해서 9로 나눈 것의 결과값은 동일하기 때문이다.
    
    ![Untitled](OpenCV-Python%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%87%E1%85%A2%E1%84%8B%E1%85%AE%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%89%E1%85%A1%E1%86%BC%20%E1%84%8E%E1%85%A5%E1%84%85%E1%85%B5%20%E1%84%86%E1%85%B5%E1%86%BE%20%E1%84%8B%E1%85%B3%E1%86%BC%E1%84%8B%E1%85%AD%E1%86%BC%209715f4cc5e8a4d7f93eb4b77751d608b/Untitled%207.png)
    
    ### 미디언 필터링
    
    중간값 필터링이라고도 하며 마스크 영역 안에 있는 화소값들을 정렬했을 때 가운데에 있는 값을 출력으로 내보낸다. 보통 영상에서의 잡음은 정렬했을 때 최상위나 최하위에 위치할 것이기 때문에 미디언 필터링은 잡음 제거로 사용할 수 있다. 하지만 정렬 연산의 비용이 크기때문에 시간이 오래걸릴 수 있다. 또한 3채널 이미지에서 한 채널에서는 주변 화소들과의 차이가 커서 제거되어도 다른 채널에서는 제거가 되지 않아 오히려 잡음이 더 많아질 수 있다. 동시에 평균값 필터링보다는 강도가 약하지만 블러링 효과도 나타난다.
    
    ![Untitled](OpenCV-Python%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%87%E1%85%A2%E1%84%8B%E1%85%AE%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%89%E1%85%A1%E1%86%BC%20%E1%84%8E%E1%85%A5%E1%84%85%E1%85%B5%20%E1%84%86%E1%85%B5%E1%86%BE%20%E1%84%8B%E1%85%B3%E1%86%BC%E1%84%8B%E1%85%AD%E1%86%BC%209715f4cc5e8a4d7f93eb4b77751d608b/Untitled%208.png)
    
    오른쪽 위에 있는 이미지는 소금-후추 잡음을 추가한 것이고 미디언 필터링을 적용했을 때 잡음이 모두 제거된 것을 확인할 수 있다.
    
    ### 가우시안 스무딩 필터링
    
    스무딩은 블러링과 같은 의미이다.  스무딩 처리에 사용되는 대표적인 방법으로 블러링이 있다.  가우시안 필터링은 가우시안 분포를 마스크의 계수로 사용하여 회선을 수행하는 것을 말한다. 축이 2개인 2차원 가우시안 분포는 다음과 같은 함수로 표현된다.
    
    $N(\mu, \sigma)(x) = \frac{1}{\rho\sqrt{2\pi}}exp(^-\frac{(x-\mu)^2}{2\sigma^2})$
    
    다음으로 3차원에서 가우시안 분포 함수는 아래와 같다.
    
    $N(\mu, \sigma)(x,y) = \frac{1}{\sigma_x\sigma_y2\pi}exp[-(\frac{(x-\mu)^2}{2\sigma^2_x}+\frac{(y-\mu)^2}{2\sigma^2_y})] = \frac{1}{2\pi\sigma^2}exp(-\frac{x^2+y^2}{2\sigma^2})$
    
    표준편차가 클수록 평균은 낮아지고 그래프의 폭이 넓게 퍼지게 된다. 즉 블러링과 비슷한 효과가 적용된다. 반대로 표준편차가 작으면 평균이 커지면서 중심계수의 값이 커지고 주변계수의 값은 작아지기 때문에 흐림의 정도가 약해진다.
    
    ![Untitled](OpenCV-Python%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%87%E1%85%A2%E1%84%8B%E1%85%AE%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%89%E1%85%A1%E1%86%BC%20%E1%84%8E%E1%85%A5%E1%84%85%E1%85%B5%20%E1%84%86%E1%85%B5%E1%86%BE%20%E1%84%8B%E1%85%B3%E1%86%BC%E1%84%8B%E1%85%AD%E1%86%BC%209715f4cc5e8a4d7f93eb4b77751d608b/Untitled%209.png)
    
    위 이미지는 왼쪽 위 원본 이미지에 커널이 17*5(가로*세로)인 크기의 가우시안 필터링 마스크를 적용한 결과이다. 커널이 가로로 길기때문에, 자동으로 표준편차가 세로보다 가로 방향으로 커지게 된다. 따라서 세로 방향으로 심하게 흐려지는 이미지가 만들어진다.
    
    ### 모폴로지(morphology)
    
    모폴로지는 형태학이란 뜻으로서 다양한 학문 분야에서 사용되는 용어이다. 영상 처리에서 모폴로지는 영상의 객체들의 형태(shape)을 분석하고 처리하는 기법이다. 이 형태학적 처리를 활용하여 영상의 경계, 골격, 블록 등의 형태를 표현하는데 필요한 요소를 추출한다.
    
    ### 침식 연산(erosion operation)
    
    객체를 침식시키는, 깎는 연산이다. 객체의 크기는 축소되고 배경은 확장된다. 따라서 잡음 같은 작은 객체들은 사라질 수 도 있다. 따라서 소금-후추 잡음과 같은 임펄스 잡음들을 제거할 수 있다. 침식 연산 마스크는 OR연산을 사용한다.
    
    | 0 | 1 | 0 |
    | --- | --- | --- |
    | 1 | 1 | 1 |
    | 0 | 1 | 0 |
    
    침식, 팽창 연산은 주로 이진 연산에서 사용되는데, 마스크에서 1에 해당하는 부분과 하나라도 겹치지 않으면 0으로 출력되고 모두 겹치면 1로 출력된다. 즉 1이 많은 영역은 그대로 1로 유지되고, 1이 적은 영역은 0으로 바뀌게 된다. 
    
    ![Untitled](OpenCV-Python%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%87%E1%85%A2%E1%84%8B%E1%85%AE%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%89%E1%85%A1%E1%86%BC%20%E1%84%8E%E1%85%A5%E1%84%85%E1%85%B5%20%E1%84%86%E1%85%B5%E1%86%BE%20%E1%84%8B%E1%85%B3%E1%86%BC%E1%84%8B%E1%85%AD%E1%86%BC%209715f4cc5e8a4d7f93eb4b77751d608b/Untitled%2010.png)
    
    왼쪽 위 이미지는 원본 이미지이고 오른쪽 위 이미지는 원본 이미지를 바이너리 이미지로 변환한 것이다. 이 이미지에 대해서 침식 연산을 수행하면 아래와 같이 출력된다. 배경은 0, 글자는 1로 이루어져 있고 글자 안에 있는 잡음은 0으로 되어있다. 이 때 침식 연산을 수행하면 배경에 있는 1의 값을 가지는 잡음은 모두 크기가 작기 때문에 없어지게 되고, 글자 안에 있는 잡음은 커지게 된다.(0의 영역이 넓어지므로)
    
    ### 팽창 연산
    
    팽창 연산은 침식 연산과 반대로 객체가 차지하는 영역을 더 많아지게 만든다. 즉 객체가 팽창하게 되고 배경은 축소된다. 
    
    | 0 | 1 | 0 |
    | --- | --- | --- |
    | 1 | 1 | 1 |
    | 0 | 1 | 0 |
    
    팽창 연산의 마스크는 침식 연산과 동일하지만 연산 과정이 반대이다. 침식 연산은 마스크와 모두 겹쳐야만 1이 출력되지만 팽창 연산은 하나라도 겹치면 1이 출력된다. 
    
    ![Untitled](OpenCV-Python%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%87%E1%85%A2%E1%84%8B%E1%85%AE%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%89%E1%85%A1%E1%86%BC%20%E1%84%8E%E1%85%A5%E1%84%85%E1%85%B5%20%E1%84%86%E1%85%B5%E1%86%BE%20%E1%84%8B%E1%85%B3%E1%86%BC%E1%84%8B%E1%85%AD%E1%86%BC%209715f4cc5e8a4d7f93eb4b77751d608b/Untitled%2011.png)
    
    위 이미지들은 원본 이미지에 팽창 연산을 적용한 이미지이다. 글자 안에 있는 잡음은 모두 사라졌지만 배경에 있는 잡음은 커졌다.
    
    ### 열림 연산과 닫힘 연산
    
    열림 연산과 닫힘 연산은 팽창과 침식 연산의 순서를 다르게 적용한 연산이다. 열림 연산은 침식→팽창 순서이고 닫힘 연산은 팽창→침식 순서이다. 열림 연산은 침식 연산이 먼저 적용되기 때문에 객체는 축소되고, 배경의 잡음은 제거된다. 이후 팽창 연산을 통해 축소되었던 객체가 원래 크기로 돌아간다. 다만 돌출된 부분은 제거된 후 원래 크기로 돌아가지 않는다. 닫힘 연산은 팽창 연산을 먼저 수행하고 침식 연산을 수행한다. 팽창 연산으로 객체가 확장되면서 객체 내 잡음이 메워진다. 다음으로 침식 연산이 수행되어 객체가 다시 원래 크기로 돌축소된다. 열림 연산은 침식→팽창이기 때문에 객체 내의 잡음이 완전히 제거되지 않는다. 반대로 닫힘 연산은 팽창→침식이기 때문에 배경의 잡음이 완전히 제거되지 않는다.